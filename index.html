<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Deocde Auto Generator</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script>
  <style>
    body {
      background-color: #ffffff;
      color: #000000;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }
    h1, h2 { color: #485d97; }
    label { display: block; margin-top: 10px; }

    input[type="text"],
    input[type="number"],
    select {
      border: 1px solid #444;
      padding: 6px 8px;
      margin-top: 4px;
      border-radius: 4px;
      background-color: #e0e0e0;
      color: #000;
    }
    input:disabled, select:disabled {
      background-color: #ffffff;
      color: #000;
    }

    button {
      cursor: pointer;
      background-color: #5e81ac;
      border: none;
      color: #ffffff;
      border-radius: 4px;
      padding: 8px 14px;
      margin-top: 6px;
    }
    button:hover { background-color: #81a1c1; }
    button.danger { background-color: #bf616a; }
    button.danger:hover { background-color: #d08770; }
    button.small { padding: 3px 8px; font-size: 12px; margin-top: 0; }

    .params-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }
    .params-grid label { margin-top: 0; }

    .field-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: flex-end;
      margin-top: 8px;
    }
    .field-row label { margin-top: 0; }

    .section-box {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 14px;
      margin-top: 14px;
    }
    .section-box-title {
      font-weight: bold;
      color: #485d97;
      margin-bottom: 8px;
    }

    /* Two-column layout */
    .page-layout {
      display: block;
    }
    .left-col {
      width: 100%;
    }
    .right-col {
      width: 100%;
      margin-top: 20px;
    }
    .canvas-sticky {
      position: static;
    }
    .canvas-sticky h2 {
      margin: 0 0 8px 0;
    }
    #fieldCanvas {
      border: 2px solid #485d97;
      border-radius: 4px;
      display: block;
      background: #1a1a1a;
      width: min(100%, 1000px);
      height: auto;
    }
    .field-legend {
      margin-top: 8px;
      font-size: 11px;
      color: #666;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .playback-controls {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #c5cfe6;
      border-radius: 6px;
      background: #eef2fb;
      display: grid;
      gap: 8px;
    }
    .playback-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .playback-time {
      font-size: 12px;
      color: #2f3c66;
      min-width: 90px;
    }
    #playbackSeek {
      width: 100%;
      margin: 0;
    }

  /* Step cards */
    #steps { margin-top: 12px; }
    .step-card {
      border: 1px solid #b0b0b0;
      border-radius: 6px;
      padding: 12px 14px;
      margin-bottom: 10px;
      background: #f5f5f5;
      position: relative;
    }
    .step-card-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .step-num {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #485d97;
      color: #fff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      font-size: 12px;
      flex-shrink: 0;
    }
    .step-card .del-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #bf616a;
      padding: 4px 10px;
      font-size: 12px;
      margin-top: 0;
    }
    .step-card .del-btn:hover { background-color: #d08770; }

    .waypoint-list { margin-top: 6px; }
    .waypoint-row {
      display: flex;
      gap: 6px;
      align-items: center;
      margin: 4px 0;
    }
    .waypoint-row input { width: 80px; margin-top: 0; }
    .waypoint-row span { color: #555; }
    .wp-picker {
      font-size: 12px;
      padding: 3px 4px;
      margin-top: 0;
      width: auto;
      max-width: 140px;
      background-color: #d0d8f0;
      color: #000;
      border: 1px solid #8899cc;
    }

    /* Output */
    #outputContainer {
      background-color: #1e1e1e;
      padding: 10px;
      border-radius: 6px;
      margin-top: 10px;
      overflow: auto;
      max-height: 600px;
    }
    pre[class*="language-"] {
      background: #1e1e1e !important;
      border: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      margin: 0 !important;
      padding: 0 !important;
      line-height: 1.5 !important;
      white-space: pre !important;
      overflow: visible !important;
    }
    code[class*="language-"] {
      background: none !important;
      font-family: Consolas, Monaco, 'Courier New', monospace !important;
      font-size: 13px !important;
    }
  </style>
</head>
<body>
<div class="page-layout">
<div class="left-col">

<h1>Deocde Robotics Auto Generator</h1>

<h2>Step 1: Setup</h2>

<label>Auto Class Name:
  <input type="text" id="autoName" placeholder="MyAuto" style="width:220px">
</label>

<div class="field-row" style="margin-top:12px">
  <label>Alliance:
    <select id="alliance">
      <option value="BLUE">Blue</option>
      <option value="RED">Red</option>
    </select>
  </label>
  <label>Start Position:
    <select id="startPos">
      <option value="CLOSE">Close</option>
      <option value="FAR">Far</option>
    </select>
  </label>
</div>

<div class="section-box">
  <div class="section-box-title">Shooter Velocity (RPM)</div>
  <div class="params-grid">
    <label>Left: <input type="number" id="veloL" value="1150"></label>
    <label>Middle: <input type="number" id="veloM" value="1150"></label>
    <label>Right: <input type="number" id="veloR" value="1150"></label>
  </div>
</div>

<div class="section-box">
  <div class="section-box-title">Hood Angles (degrees)</div>
  <div class="params-grid">
    <label>Left: <input type="number" id="hoodL" value="30"></label>
    <label>Middle: <input type="number" id="hoodM" value="30"></label>
    <label>Right: <input type="number" id="hoodR" value="30"></label>
  </div>
</div>

<div class="section-box">
  <div class="section-box-title">Turret</div>
  <label>Shooting Angle — field-centric (degrees):
    <input type="number" id="turretAngle" value="142" style="width:100px">
  </label>
  <label>Pre-aim Angle — robot-centric (degrees):
    <input type="number" id="preAimAngle" value="-90" style="width:100px">
  </label>
</div>

<h2>Step 2: Path Steps</h2>
<p style="margin:4px 0 8px 0; color:#555; font-size:14px">
  Each step maps directly to a chained call on <code>SixWheelPIDPathBuilder</code>.
  Steps execute in order.
</p>
<div id="steps"></div>
<button onclick="addStep()">+ Add Step</button>

<h2>Generated Auto Class</h2>
<div id="outputContainer">
  <pre><code id="output" class="language-java"></code></pre>
</div>
<button id="copyBtn" style="margin-top:10px">Copy to Clipboard</button>

</div><!-- .left-col -->

<div class="right-col">
  <div class="canvas-sticky">
    <h2>Field Preview</h2>
    <canvas id="fieldCanvas" width="1000" height="1000"></canvas>
    <div class="field-legend">
      <div class="legend-item"><div class="legend-dot" style="background:#5e81ac;border:2px solid #fff"></div><span>Start</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#88c0d0"></div><span>Drive</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#ebcb8b"></div><span>Turn</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#bf616a"></div><span>⚡ Shoot</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#81a1c1"></div><span>⏸ Wait</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#d08770"></div><span>↺ Transfer</span></div>
      <div class="legend-item"><div class="legend-dot" style="background:#ebcb8b"></div><span>◎ Aim</span></div>
    </div>
    <div class="playback-controls">
      <div class="playback-row">
        <button id="playPauseBtn" type="button">Play</button>
        <button id="resetPlaybackBtn" type="button">Reset</button>
        <label style="margin:0">Speed:
          <select id="playbackSpeed" style="margin-top:0">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1.0x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2.0x</option>
          </select>
        </label>
        <span id="playbackTime" class="playback-time">0.00s / 0.00s</span>
      </div>
      <input id="playbackSeek" type="range" min="0" max="1000" value="0">
    </div>
  </div>
</div><!-- .right-col -->

</div><!-- .page-layout -->

<script>
  // ── Constants ──────────────────────────────────────────────────────────────

  const START_POSES = {
    BLUE_CLOSE: { x: -49, y: -54, heading: 51.529 },
    BLUE_FAR:   { x:  63, y:  -7, heading: -90     },
    RED_CLOSE:  { x: -51, y:  54, heading: -51.529 },
    RED_FAR:    { x:  63, y:   7, heading:  90     }
  };

  const DEFAULTS = {
    BLUE_CLOSE: { veloL: 1150, veloM: 1150, veloR: 1150, hoodL: 30, hoodM: 30, hoodR: 30, turret: 142,  preAim: -90  },
    BLUE_FAR:   { veloL: 1440, veloM: 1440, veloR: 1430, hoodL: 49, hoodM: 45, hoodR: 49, turret: 156,  preAim: -116 },
    RED_CLOSE:  { veloL: 1120, veloM: 1120, veloR: 1120, hoodL: 34, hoodM: 34, hoodR: 34, turret: 223,  preAim:  90  },
    RED_FAR:    { veloL: 1440, veloM: 1440, veloR: 1440, hoodL: 49, hoodM: 45, hoodR: 49, turret: 201,  preAim:  116 }
  };

  // ── Known Field Points ─────────────────────────────────────────────────────
  // shootPreset: if present, selecting this point also fills velocity/hood/turret

  const KNOWN_POINTS = {
    BLUE_CLOSE: [
      { label: 'Start',           x: -49, y: -54 },
      { label: 'Shooting Pos',    x: -16, y: -19, shootPreset: { veloL: 1150, veloM: 1150, veloR: 1150, hoodL: 30, hoodM: 30, hoodR: 30, turret: 142, preAim: -90 } },
      { label: 'Close Intake 1',  x:  -6, y: -45 },
      { label: 'Close Intake 2',  x:  -5, y: -57 },
      { label: 'Close Intake 3',  x:  -8, y: -49 },
      { label: 'Gate Intake',     x:  13, y: -49 },
      { label: 'Far Gate Intake', x:  39, y: -46 },
    ],
    BLUE_FAR: [
      { label: 'Start',           x:  63, y:  -7 },
      { label: 'Shooting Pos',    x:  45, y:  -9, shootPreset: { veloL: 1440, veloM: 1440, veloR: 1430, hoodL: 49, hoodM: 45, hoodR: 49, turret: 156, preAim: -116 } },
      { label: 'Wing Intake 1',   x:  37, y: -50 },
      { label: 'Wing Intake 2',   x:  40, y: -40 },
      { label: 'Wall Approach',   x:  61, y: -45 },
      { label: 'Wall Pickup',     x:  63, y: -62 },
    ],
    RED_CLOSE: [
      { label: 'Start',           x: -49, y:  54 },
      { label: 'Shooting Pos',    x: -16, y:  19, shootPreset: { veloL: 1120, veloM: 1140, veloR: 1120, hoodL: 34, hoodM: 34, hoodR: 34, turret: 218, preAim: 90 } },
      { label: 'Middle Intake 1', x:  12, y:  25 },
      { label: 'Middle Intake 2', x:  12, y:  59 },
      { label: 'Close Intake',    x:  -8, y:  49 },
      { label: 'Gate Approach',   x:  19, y:  45 },
      { label: 'Gate Area',       x:  14, y:  58 },
    ],
    RED_FAR: [
      { label: 'Start',           x:  63, y:   7 },
      { label: 'Shooting Pos',    x:  45, y:   9, shootPreset: { veloL: 1440, veloM: 1440, veloR: 1440, hoodL: 49, hoodM: 45, hoodR: 49, turret: 201, preAim: 116 } },
      { label: 'Wing Intake 1',   x:  40, y:  48 },
      { label: 'Wall Approach',   x:  61, y:  45 },
      { label: 'Wall Pickup',     x:  63, y:  62 },
    ],
  };

  const FIELD_MIN = -72;
  const FIELD_MAX = 72;
  const FIELD_SIZE_IN = FIELD_MAX - FIELD_MIN;
  const ROBOT_BOX_SIZE_IN = 18;
  const DRIVE_IN_PER_SEC_AT_2000 = 50;

  const playback = {
    isPlaying: false,
    speed: 1,
    tMs: 0,
    durationMs: 0,
    lastTs: 0,
    segments: [],
    rafId: null
  };

  // ── Helpers ────────────────────────────────────────────────────────────────

  function getKey() {
    return document.getElementById('alliance').value + '_' + document.getElementById('startPos').value;
  }

  function sanitize(raw) {
    let n = raw.trim().replace(/[^a-zA-Z0-9]/g, '_').replace(/_+/g, '_').replace(/_+$/, '');
    return n.length > 0 ? n[0].toUpperCase() + n.slice(1) : 'MyAuto';
  }

  function mirrorMapY(y) {
    return -y;
  }

  function headingFromVector(dx, dy) {
    return Math.atan2(dx, dy) * 180 / Math.PI;
  }

  function getDriveWaypoints(card) {
    const wpRows = card.querySelectorAll('.waypoint-row');
    const pts = [];
    wpRows.forEach(row => {
      const x = parseFloat(row.querySelector('.wp-x').value);
      const y = parseFloat(row.querySelector('.wp-y').value);
      if (!isNaN(x) && !isNaN(y)) pts.push([x, y]);
    });
    return pts;
  }

  function formatTimeMs(ms) {
    return `${(Math.max(0, ms) / 1000).toFixed(2)}s`;
  }

  function applyDefaults() {
    const d = DEFAULTS[getKey()];
    if (!d) return;
    document.getElementById('veloL').value = d.veloL;
    document.getElementById('veloM').value = d.veloM;
    document.getElementById('veloR').value = d.veloR;
    document.getElementById('hoodL').value = d.hoodL;
    document.getElementById('hoodM').value = d.hoodM;
    document.getElementById('hoodR').value = d.hoodR;
    document.getElementById('turretAngle').value = d.turret;
    document.getElementById('preAimAngle').value = d.preAim;
    repopulateAllPickers();
    regenerate();
  }

  // ── Step management ────────────────────────────────────────────────────────

  let stepCounter = 0;

  function addStep() {
    stepCounter++;
    const card = document.createElement('div');
    card.className = 'step-card';

    // Header row
    const header = document.createElement('div');
    header.className = 'step-card-header';

    const numBadge = document.createElement('span');
    numBadge.className = 'step-num';

    const typeSelect = document.createElement('select');
    typeSelect.className = 'step-type';
    ['Drive', 'Drive + Turn', 'Turn', 'Wait', 'Shoot', 'Transfer', 'Aim Turret'].forEach(t => {
      const o = document.createElement('option');
      o.value = t; o.textContent = t;
      typeSelect.appendChild(o);
    });

    header.appendChild(numBadge);
    header.appendChild(typeSelect);
    card.appendChild(header);

    // Params area
    const params = document.createElement('div');
    params.className = 'step-params';
    card.appendChild(params);

    // Delete button
    const del = document.createElement('button');
    del.textContent = 'Delete';
    del.className = 'del-btn';
    del.onclick = () => { card.remove(); renumber(); regenerate(); };
    card.appendChild(del);

    typeSelect.onchange = () => { renderParams(typeSelect.value, params); regenerate(); };
    renderParams(typeSelect.value, params);

    document.getElementById('steps').appendChild(card);
    renumber();
    regenerate();
  }

  function renumber() {
    document.querySelectorAll('.step-card .step-num').forEach((el, i) => {
      el.textContent = i + 1;
    });
  }

  // ── Param renderers ────────────────────────────────────────────────────────

  function renderParams(type, container) {
    container.innerHTML = '';

    if (type === 'Drive') {
      const veloRow = document.createElement('div');
      veloRow.innerHTML = '<label>Max Velocity: <input type="number" class="p-velo" value="2000" style="width:100px"> <span style="color:#555;font-size:13px">(ticks/s)</span></label>';
      veloRow.querySelector('.p-velo').oninput = regenerate;
      container.appendChild(veloRow);

      const wpSection = document.createElement('div');
      wpSection.style.marginTop = '10px';

      const wpTitle = document.createElement('div');
      wpTitle.style.cssText = 'font-size:13px;color:#333;margin-bottom:4px';
      wpTitle.textContent = 'Waypoints (x, y) — in order:';
      wpSection.appendChild(wpTitle);

      const wpList = document.createElement('div');
      wpList.className = 'waypoint-list';
      wpSection.appendChild(wpList);

      const addBtn = document.createElement('button');
      addBtn.className = 'small';
      addBtn.textContent = '+ Waypoint';
      addBtn.style.marginTop = '6px';
      addBtn.onclick = e => { e.preventDefault(); addWaypoint(wpList); regenerate(); };
      wpSection.appendChild(addBtn);

      container.appendChild(wpSection);
      addWaypoint(wpList);
      addWaypoint(wpList);

    } else if (type === 'Drive + Turn') {
      // Turn order selector
      const orderDiv = document.createElement('div');
      orderDiv.className = 'field-row';
      orderDiv.innerHTML = `
        <label>Order:
          <select class="p-dt-order">
            <option value="turn_first">Turn first, then drive</option>
            <option value="drive_first">Drive first, then turn</option>
          </select>
        </label>
        <label>Turn Angle (°): <input type="number" class="p-dt-angle" value="-90" style="width:90px"></label>
        <label>Turn Timeout (ms): <input type="number" class="p-dt-timeout" value="1000" style="width:90px"></label>`;
      orderDiv.querySelector('.p-dt-order').onchange = regenerate;
      orderDiv.querySelector('.p-dt-angle').oninput = regenerate;
      orderDiv.querySelector('.p-dt-timeout').oninput = regenerate;
      container.appendChild(orderDiv);

      // Drive params (same as Drive)
      const veloRow = document.createElement('div');
      veloRow.innerHTML = '<label style="margin-top:8px">Drive Max Velocity: <input type="number" class="p-velo" value="2000" style="width:100px"> <span style="color:#555;font-size:13px">(ticks/s)</span></label>';
      veloRow.querySelector('.p-velo').oninput = regenerate;
      container.appendChild(veloRow);

      const wpSection = document.createElement('div');
      wpSection.style.marginTop = '10px';
      const wpTitle = document.createElement('div');
      wpTitle.style.cssText = 'font-size:13px;color:#333;margin-bottom:4px';
      wpTitle.textContent = 'Waypoints (x, y) — in order:';
      wpSection.appendChild(wpTitle);
      const wpList = document.createElement('div');
      wpList.className = 'waypoint-list';
      wpSection.appendChild(wpList);
      const addBtn = document.createElement('button');
      addBtn.className = 'small';
      addBtn.textContent = '+ Waypoint';
      addBtn.style.marginTop = '6px';
      addBtn.onclick = e => { e.preventDefault(); addWaypoint(wpList); regenerate(); };
      wpSection.appendChild(addBtn);
      container.appendChild(wpSection);
      addWaypoint(wpList);
      addWaypoint(wpList);

    } else if (type === 'Turn') {
      const div = document.createElement('div');
      div.className = 'field-row';
      div.innerHTML = `
        <label>Angle (°): <input type="number" class="p-turn-angle" value="-90" style="width:90px"></label>
        <label>Timeout (ms): <input type="number" class="p-turn-timeout" value="1000" style="width:90px"></label>`;
      div.querySelector('.p-turn-angle').oninput = regenerate;
      div.querySelector('.p-turn-timeout').oninput = regenerate;
      container.appendChild(div);

    } else if (type === 'Wait') {
      const div = document.createElement('div');
      div.innerHTML = '<label>Duration (ms): <input type="number" class="p-wait-ms" value="500" style="width:100px"></label>';
      div.querySelector('.p-wait-ms').oninput = regenerate;
      container.appendChild(div);

    } else if (type === 'Shoot') {
      const div = document.createElement('div');
      div.innerHTML = `
        <label style="margin-top:4px"><input type="checkbox" class="p-antijam"> Use <code>AutonomousShootAntiJamCommand</code> instead of normal shoot</label>
        <label style="margin-top:6px"><input type="checkbox" class="p-spit"> Spit intake after shoot (WaitCommand 300ms + IntakeSpitCommand)</label>`;
      div.querySelector('.p-antijam').onchange = regenerate;
      div.querySelector('.p-spit').onchange = regenerate;
      container.appendChild(div);

    } else if (type === 'Transfer') {
      const div = document.createElement('div');
      div.innerHTML = `
        <label>Wait after transfer (ms): <input type="number" class="p-tf-wait" value="1000" style="width:100px"></label>
        <label style="margin-top:6px"><input type="checkbox" class="p-preaim"> Pre-aim turret after transfer (<code>TurnTurretToPosCommand(preAimTurretAngle)</code>)</label>`;
      div.querySelector('.p-tf-wait').oninput = regenerate;
      div.querySelector('.p-preaim').onchange = regenerate;
      container.appendChild(div);

    } else if (type === 'Aim Turret') {
      const div = document.createElement('div');
      div.innerHTML = `
        <label>Mode:
          <select class="p-aim-mode">
            <option value="field_stored">Field-centric — use stored <code>turretAngle</code></option>
            <option value="field_custom">Field-centric — custom angle</option>
            <option value="robot_stored">Robot-centric — use stored <code>preAimTurretAngle</code></option>
            <option value="robot_custom">Robot-centric — custom angle</option>
          </select>
        </label>
        <label class="custom-angle-row" style="display:none;margin-top:8px">
          Custom Angle (°): <input type="number" class="p-aim-angle" value="0" style="width:90px">
        </label>`;
      const modeSelect = div.querySelector('.p-aim-mode');
      const customRow = div.querySelector('.custom-angle-row');
      modeSelect.onchange = () => {
        customRow.style.display = modeSelect.value.includes('custom') ? 'block' : 'none';
        regenerate();
      };
      div.querySelector('.p-aim-angle').oninput = regenerate;
      container.appendChild(div);
    }
  }

  function addWaypoint(list) {
    const row = document.createElement('div');
    row.className = 'waypoint-row';

    const xIn = document.createElement('input');
    xIn.type = 'number'; xIn.placeholder = 'x'; xIn.className = 'wp-x'; xIn.oninput = regenerate;

    const yIn = document.createElement('input');
    yIn.type = 'number'; yIn.placeholder = 'y'; yIn.className = 'wp-y'; yIn.oninput = regenerate;

    // Named-point picker
    const picker = document.createElement('select');
    picker.className = 'wp-picker';

    function populatePicker() {
      picker.innerHTML = '<option value="">— named point —</option>';
      (KNOWN_POINTS[getKey()] || []).forEach((pt, i) => {
        const o = document.createElement('option');
        o.value = i; o.textContent = pt.label;
        picker.appendChild(o);
      });
    }
    populatePicker();
    row._populatePicker = populatePicker;

    picker.onchange = () => {
      if (picker.value === '') return;
      const pt = (KNOWN_POINTS[getKey()] || [])[parseInt(picker.value)];
      if (!pt) return;
      xIn.value = pt.x;
      yIn.value = pt.y;
      if (pt.shootPreset) {
        const p = pt.shootPreset;
        document.getElementById('veloL').value = p.veloL;
        document.getElementById('veloM').value = p.veloM;
        document.getElementById('veloR').value = p.veloR;
        document.getElementById('hoodL').value = p.hoodL;
        document.getElementById('hoodM').value = p.hoodM;
        document.getElementById('hoodR').value = p.hoodR;
        document.getElementById('turretAngle').value = p.turret;
        document.getElementById('preAimAngle').value = p.preAim;
      }
      picker.value = '';
      regenerate();
    };

    const rm = document.createElement('button');
    rm.textContent = '×'; rm.className = 'danger small';
    rm.onclick = e => { e.preventDefault(); row.remove(); regenerate(); };

    row.appendChild(picker);
    row.appendChild(document.createTextNode(' x: ')); row.appendChild(xIn);
    row.appendChild(document.createTextNode('  y: ')); row.appendChild(yIn);
    row.appendChild(rm);
    list.appendChild(row);
  }

  function repopulateAllPickers() {
    document.querySelectorAll('.waypoint-row').forEach(row => {
      if (row._populatePicker) row._populatePicker();
    });
  }

  // ── Code generation ────────────────────────────────────────────────────────

  // Indentation constants (spaces from left margin in generated Java)
  // Inner class constructor body = 12 spaces
  // Chain method calls           = 20 spaces  (12 + 8)
  // Callback body                = 24 spaces  (20 + 4)
  // SequentialCommandGroup args  = 32 spaces  (24 + 8)
  const IND_CHAIN  = '                    ';   // 20 sp
  const IND_CB     = '                        '; // 24 sp
  const IND_ARGS   = '                                '; // 32 sp

  function buildSegment(card) {
    const type = card.querySelector('.step-type').value;

    if (type === 'Drive') {
      const velo = card.querySelector('.p-velo')?.value || '2000';
      const wpRows = card.querySelectorAll('.waypoint-row');
      if (wpRows.length === 0) return null;
      const pts = Array.from(wpRows).map(r => {
        const x = r.querySelector('.wp-x').value || '0';
        const y = r.querySelector('.wp-y').value || '0';
        return `${IND_CHAIN}        new Point2d(${x}, ${y})`;
      });
      return `.addPurePursuitPath(new Point2d[]{\n${pts.join(',\n')}\n${IND_CHAIN}}, ${velo})`;

    } else if (type === 'Drive + Turn') {
      const order   = card.querySelector('.p-dt-order')?.value   || 'turn_first';
      const angle   = card.querySelector('.p-dt-angle')?.value   || '0';
      const timeout = card.querySelector('.p-dt-timeout')?.value || '1000';
      const velo    = card.querySelector('.p-velo')?.value       || '2000';
      const wpRows  = card.querySelectorAll('.waypoint-row');
      if (wpRows.length === 0) return null;
      const pts = Array.from(wpRows).map(r => {
        const x = r.querySelector('.wp-x').value || '0';
        const y = r.querySelector('.wp-y').value || '0';
        return `${IND_CHAIN}        new Point2d(${x}, ${y})`;
      });
      const turnCall  = `.addTurnTo(${angle}, ${timeout})`;
      const driveCall = `.addPurePursuitPath(new Point2d[]{\n${pts.join(',\n')}\n${IND_CHAIN}}, ${velo})`;
      return order === 'turn_first'
        ? `${turnCall}\n${IND_CHAIN}${driveCall}`
        : `${driveCall}\n${IND_CHAIN}${turnCall}`;

    } else if (type === 'Turn') {
      const angle   = card.querySelector('.p-turn-angle')?.value   || '0';
      const timeout = card.querySelector('.p-turn-timeout')?.value || '1000';
      return `.addTurnTo(${angle}, ${timeout})`;

    } else if (type === 'Wait') {
      const ms = card.querySelector('.p-wait-ms')?.value || '500';
      return `.waitMilliseconds(${ms})`;

    } else if (type === 'Shoot') {
      const antiJam = card.querySelector('.p-antijam')?.checked;
      const spit    = card.querySelector('.p-spit')?.checked;
      const cmd = antiJam ? 'new AutonomousShootAntiJamCommand()' : 'new AutonomousShootCommand()';
      if (spit) {
        return `.callback(() -> {\n${IND_CB}new SequentialCommandGroup(\n${IND_ARGS}${cmd},\n${IND_ARGS}new WaitCommand(300),\n${IND_ARGS}new IntakeSpitCommand()\n${IND_CB}).schedule();\n${IND_CHAIN}})`;
      }
      return `.callback(() -> {\n${IND_CB}new SequentialCommandGroup(\n${IND_ARGS}${cmd}\n${IND_CB}).schedule();\n${IND_CHAIN}})`;

    } else if (type === 'Transfer') {
      const waitMs = card.querySelector('.p-tf-wait')?.value || '1000';
      const preAim = card.querySelector('.p-preaim')?.checked;
      const cmds = [
        'new SetShooterVelocityIndependentCommand(velo, veloMiddle, velo)',
        'new AutonomousTransferCommand(leftHood, middleHood, rightHood)'
      ];
      if (parseInt(waitMs) > 0) cmds.push(`new WaitCommand(${waitMs})`);
      if (preAim)               cmds.push('new TurnTurretToPosCommand(preAimTurretAngle)');
      const inner = cmds.map(c => `${IND_ARGS}${c}`).join(',\n');
      return `.callback(() -> {\n${IND_CB}new SequentialCommandGroup(\n${inner}\n${IND_CB}).schedule();\n${IND_CHAIN}})`;

    } else if (type === 'Aim Turret') {
      const mode        = card.querySelector('.p-aim-mode')?.value || 'field_stored';
      const customAngle = card.querySelector('.p-aim-angle')?.value || '0';
      let cls, arg;
      if      (mode === 'field_stored') { cls = 'TurnTurretToPosFieldCentricCommand'; arg = 'turretAngle';     }
      else if (mode === 'field_custom') { cls = 'TurnTurretToPosFieldCentricCommand'; arg = customAngle;       }
      else if (mode === 'robot_stored') { cls = 'TurnTurretToPosCommand';             arg = 'preAimTurretAngle'; }
      else                              { cls = 'TurnTurretToPosCommand';             arg = customAngle;       }
      return `.callback(() -> {\n${IND_CB}new ${cls}(${arg}).schedule();\n${IND_CHAIN}})`;
    }
    return null;
  }

  function regenerate() {
    const rawName = document.getElementById('autoName').value || 'MyAuto';
    const className = sanitize(rawName);
    const key = getKey();
    const pose = START_POSES[key];
    const alliance = document.getElementById('alliance').value;
    const veloL = document.getElementById('veloL').value;
    const veloM = document.getElementById('veloM').value;
    const veloR = document.getElementById('veloR').value;
    const hoodL = document.getElementById('hoodL').value;
    const hoodM = document.getElementById('hoodM').value;
    const hoodR = document.getElementById('hoodR').value;
    const turretAngle = document.getElementById('turretAngle').value;
    const preAimAngle = document.getElementById('preAimAngle').value;

    // Collect path segments from step cards
    const cards = document.querySelectorAll('.step-card');
    let usesAntiJam = false, usesSpit = false;
    const segments = [];
    cards.forEach(card => {
      const type = card.querySelector('.step-type').value;
      if (type === 'Shoot') {
        if (card.querySelector('.p-antijam')?.checked) usesAntiJam = true;
        if (card.querySelector('.p-spit')?.checked)    usesSpit    = true;
      }
      const seg = buildSegment(card);
      if (seg) segments.push(seg);
    });

    // Build path chain inside inner class constructor
    const pathBody = segments.length === 0
      ? '            // No steps added yet — click "+ Add Step" above'
      : '            this\n' + IND_CHAIN + segments.join('\n' + IND_CHAIN) + ';';

    // Shooter velocity call
    const veloCall = (veloL === veloM && veloM === veloR)
      ? `shooter.shootWithVelocity(${veloL});`
      : `shooter.shootWithVelocityIndependent(${veloL}, ${veloM}, ${veloR});`;

    // Heading string (avoid ".0" for whole numbers)
    const heading = pose.heading;
    const headingStr = Number.isInteger(heading) ? heading.toFixed(1) : String(heading);

    // Optional imports
    const antiJamImport = usesAntiJam
      ? 'import org.firstinspires.ftc.teamcode.blucru.common.commands.autonomousCommands.AutonomousShootAntiJamCommand;\n'
      : '';
    const spitImport = usesSpit
      ? 'import org.firstinspires.ftc.teamcode.blucru.common.subsytems.intake.IntakeSpitCommand;\n'
      : '';

    const code =
`package org.firstinspires.ftc.teamcode.blucru.opmodes.auto;

import com.seattlesolvers.solverslib.command.SequentialCommandGroup;
import com.seattlesolvers.solverslib.command.WaitCommand;
import com.qualcomm.robotcore.eventloop.opmode.Autonomous;

import org.firstinspires.ftc.teamcode.blucru.common.commands.autonomousCommands.AutonomousShootCommand;
${antiJamImport}${spitImport}import org.firstinspires.ftc.teamcode.blucru.common.commands.autonomousCommands.AutonomousTransferCommand;
import org.firstinspires.ftc.teamcode.blucru.common.pathing.Path;
import org.firstinspires.ftc.teamcode.blucru.common.pathing.SixWheelPIDPathBuilder;
import org.firstinspires.ftc.teamcode.blucru.common.subsytems.outtake.shooter.shooterCommands.SetShooterVelocityIndependentCommand;
import org.firstinspires.ftc.teamcode.blucru.common.subsytems.outtake.turret.turretCommands.TurnTurretToPosCommand;
import org.firstinspires.ftc.teamcode.blucru.common.subsytems.outtake.turret.turretCommands.TurnTurretToPosFieldCentricCommand;
import org.firstinspires.ftc.teamcode.blucru.common.util.Alliance;
import org.firstinspires.ftc.teamcode.blucru.common.util.Globals;
import org.firstinspires.ftc.teamcode.blucru.common.util.Point2d;
import org.firstinspires.ftc.teamcode.blucru.common.util.Pose2d;
import com.sfdev.assembly.state.StateMachine;
import com.sfdev.assembly.state.StateMachineBuilder;

@Autonomous
public class Auto_${className} extends BaseAuto {
    double turretAngle     = ${turretAngle};
    double preAimTurretAngle = ${preAimAngle};
    double velo            = ${veloL};
    double veloMiddle      = ${veloM};
    double leftHood        = ${hoodL};
    double middleHood      = ${hoodM};
    double rightHood       = ${hoodR};

    enum State { RUNNING }

    public class AutoPath extends SixWheelPIDPathBuilder {
        public AutoPath() {
            super();
${pathBody}
        }
    }

    Path currentPath;

    @Override
    public Pose2d getStartPose() {
        return new Pose2d(${pose.x}, ${pose.y}, Math.toRadians(${headingStr}));
    }

    @Override
    public StateMachine buildStateMachine() {
        return new StateMachineBuilder()
                .state(State.RUNNING)
                .loop(() -> {
                    if (currentPath != null) {
                        currentPath.run();
                    }
                })
                .build();
    }

    @Override
    public void initialize() {
        shooter.setHoodAngleIndependent(${hoodL}, ${hoodM}, ${hoodR});
        shooter.write();
        elevator.setMiddle();
        elevator.write();
        transfer.setAllMiddle();
        transfer.write();
        turret.resetEncoder();
        turret.write();
        sixWheel.reset();
        sixWheel.write();
        intake.resetEncoder();
        intake.write();
        super.initialize();
    }

    @Override
    public void onStart() {
        ${veloCall}
        turret.setAngle(5);
        sixWheel.setPosition(startPose);
        currentPath = new AutoPath().build().start();
        Globals.setAlliance(Alliance.${alliance});
        sm.setState(State.RUNNING);
        sm.start();
    }

    @Override
    public void periodic() {
        sm.update();
    }
}`;

    const box = document.getElementById('output');
    box.textContent = code;
    Prism.highlightElement(box);
    buildMotionTimeline();
    renderField();
  }

  // ── Field Visualizer ───────────────────────────────────────────────────────

  const FIELD_COLORS = ['#88c0d0','#a3be8c','#d08770','#bf616a','#b48ead','#8fbcbb','#81a1c1'];

  // Pre-load field image once
  const fieldImg = new Image();
  fieldImg.src = 'field.webp';
  fieldImg.onload = renderField;

  function polylineLength(points) {
    let total = 0;
    for (let i = 1; i < points.length; i++) {
      const dx = points[i][0] - points[i - 1][0];
      const dy = points[i][1] - points[i - 1][1];
      total += Math.hypot(dx, dy);
    }
    return total;
  }

  function buildMotionTimeline() {
    const key = getKey();
    const pose = START_POSES[key];
    let px = pose.x, py = pose.y, heading = pose.heading;
    let tMs = 0;
    const segs = [];

    const pushHold = (label, durationMs) => {
      const dur = Math.max(0, durationMs);
      segs.push({ type: 'hold', label, startMs: tMs, endMs: tMs + dur, x: px, y: py, heading });
      tMs += dur;
    };

    const pushTurn = (angleDeg, timeoutMs, label) => {
      const turnDur = Math.max(120, isNaN(timeoutMs) ? 800 : Math.abs(timeoutMs));
      const startHeading = heading;
      const endHeading = startHeading + (isNaN(angleDeg) ? 0 : angleDeg);
      segs.push({
        type: 'turn',
        label,
        startMs: tMs,
        endMs: tMs + turnDur,
        x: px,
        y: py,
        startHeading,
        endHeading
      });
      tMs += turnDur;
      heading = endHeading;
    };

    const pushDrive = (pts, veloRaw, label) => {
      if (!pts.length) return;
      const path = [[px, py], ...pts];
      const lengthIn = polylineLength(path);
      if (lengthIn <= 0.001) return;
      const velo = Math.max(1, isNaN(veloRaw) ? 2000 : Math.abs(veloRaw));
      const speedInPerSec = Math.max(8, (velo / 2000) * DRIVE_IN_PER_SEC_AT_2000);
      const duration = Math.max(120, (lengthIn / speedInPerSec) * 1000);
      segs.push({
        type: 'drive',
        label,
        startMs: tMs,
        endMs: tMs + duration,
        path,
        lengthIn
      });
      tMs += duration;
      const [lx, ly] = pts[pts.length - 1];
      if (pts.length > 0) {
        const [sx, sy] = path[path.length - 2];
        heading = headingFromVector(lx - sx, ly - sy);
      }
      px = lx;
      py = ly;
    };

    document.querySelectorAll('.step-card').forEach((card, i) => {
      const type = card.querySelector('.step-type').value;
      const label = `${i + 1} ${type}`;

      if (type === 'Drive') {
        pushDrive(getDriveWaypoints(card), parseFloat(card.querySelector('.p-velo')?.value || '2000'), label);
      } else if (type === 'Drive + Turn') {
        const pts = getDriveWaypoints(card);
        const order = card.querySelector('.p-dt-order')?.value || 'turn_first';
        const angle = parseFloat(card.querySelector('.p-dt-angle')?.value || '0');
        const timeout = parseFloat(card.querySelector('.p-dt-timeout')?.value || '1000');
        if (order === 'turn_first') {
          pushTurn(angle, timeout, `${label} turn`);
          pushDrive(pts, parseFloat(card.querySelector('.p-velo')?.value || '2000'), `${label} drive`);
        } else {
          pushDrive(pts, parseFloat(card.querySelector('.p-velo')?.value || '2000'), `${label} drive`);
          pushTurn(angle, timeout, `${label} turn`);
        }
      } else if (type === 'Turn') {
        const angle = parseFloat(card.querySelector('.p-turn-angle')?.value || '0');
        const timeout = parseFloat(card.querySelector('.p-turn-timeout')?.value || '1000');
        pushTurn(angle, timeout, label);
      } else if (type === 'Wait') {
        const ms = parseFloat(card.querySelector('.p-wait-ms')?.value || '500');
        pushHold(label, isNaN(ms) ? 500 : ms);
      } else if (type === 'Shoot') {
        pushHold(label, 450);
      } else if (type === 'Transfer') {
        const ms = parseFloat(card.querySelector('.p-tf-wait')?.value || '1000');
        pushHold(label, Math.max(400, isNaN(ms) ? 1000 : ms));
      } else if (type === 'Aim Turret') {
        pushHold(label, 300);
      }
    });

    playback.segments = segs;
    playback.durationMs = Math.max(0, tMs);
    if (playback.tMs > playback.durationMs) playback.tMs = playback.durationMs;
    if (playback.isPlaying && playback.durationMs === 0) stopPlayback();
    playback.tMs = Math.min(playback.tMs, playback.durationMs);
    updatePlaybackUi();
  }

  function interpolateOnPath(path, progress) {
    if (!path.length) return null;
    if (path.length === 1) return { x: path[0][0], y: path[0][1], heading: 0 };

    const total = polylineLength(path);
    if (total <= 0.001) return { x: path[path.length - 1][0], y: path[path.length - 1][1], heading: 0 };

    let remaining = Math.max(0, Math.min(1, progress)) * total;
    for (let i = 1; i < path.length; i++) {
      const [x1, y1] = path[i - 1];
      const [x2, y2] = path[i];
      const segLen = Math.hypot(x2 - x1, y2 - y1);
      if (remaining <= segLen || i === path.length - 1) {
        const u = segLen <= 1e-6 ? 1 : Math.max(0, Math.min(1, remaining / segLen));
        return {
          x: x1 + (x2 - x1) * u,
          y: y1 + (y2 - y1) * u,
          heading: headingFromVector(x2 - x1, y2 - y1)
        };
      }
      remaining -= segLen;
    }
    const last = path[path.length - 1];
    const prev = path[path.length - 2];
    return { x: last[0], y: last[1], heading: headingFromVector(last[0] - prev[0], last[1] - prev[1]) };
  }

  function getPlaybackPoseAt(tMs) {
    const key = getKey();
    const pose = START_POSES[key];
    if (!playback.segments.length) return { x: pose.x, y: pose.y, heading: pose.heading, label: 'Start' };

    const t = Math.max(0, Math.min(playback.durationMs, tMs));
    let seg = playback.segments.find(s => t <= s.endMs) || playback.segments[playback.segments.length - 1];
    if (!seg) return { x: pose.x, y: pose.y, heading: pose.heading, label: 'Start' };

    if (seg.type === 'drive') {
      const span = Math.max(1, seg.endMs - seg.startMs);
      const p = (t - seg.startMs) / span;
      const ip = interpolateOnPath(seg.path, p);
      return { x: ip.x, y: ip.y, heading: ip.heading, label: seg.label };
    }
    if (seg.type === 'turn') {
      const span = Math.max(1, seg.endMs - seg.startMs);
      const p = (t - seg.startMs) / span;
      return {
        x: seg.x,
        y: seg.y,
        heading: seg.startHeading + (seg.endHeading - seg.startHeading) * p,
        label: seg.label
      };
    }
    return { x: seg.x, y: seg.y, heading: seg.heading, label: seg.label };
  }

  function updatePlaybackUi() {
    const seek = document.getElementById('playbackSeek');
    const time = document.getElementById('playbackTime');
    const playBtn = document.getElementById('playPauseBtn');
    if (!seek || !time || !playBtn) return;
    const max = Math.max(1, Math.round(playback.durationMs));
    seek.max = String(max);
    seek.value = String(Math.min(max, Math.round(playback.tMs)));
    time.textContent = `${formatTimeMs(playback.tMs)} / ${formatTimeMs(playback.durationMs)}`;
    playBtn.textContent = playback.isPlaying ? 'Pause' : 'Play';
  }

  function stopPlayback() {
    playback.isPlaying = false;
    playback.lastTs = 0;
    if (playback.rafId) {
      cancelAnimationFrame(playback.rafId);
      playback.rafId = null;
    }
    updatePlaybackUi();
  }

  function playbackTick(ts) {
    if (!playback.isPlaying) return;
    if (!playback.lastTs) playback.lastTs = ts;
    const dt = ts - playback.lastTs;
    playback.lastTs = ts;
    playback.tMs += dt * playback.speed;
    if (playback.tMs >= playback.durationMs) {
      playback.tMs = playback.durationMs;
      stopPlayback();
      renderField();
      return;
    }
    updatePlaybackUi();
    renderField();
    playback.rafId = requestAnimationFrame(playbackTick);
  }

  function startPlayback() {
    if (!playback.durationMs) return;
    playback.isPlaying = true;
    playback.lastTs = 0;
    updatePlaybackUi();
    if (!playback.rafId) playback.rafId = requestAnimationFrame(playbackTick);
  }

  function drawRobotBox(ctx, toC, fx, fy, strokeStyle, fillStyle) {
    const [cx, cy] = toC(fx, fy);
    const halfW = (ROBOT_BOX_SIZE_IN / FIELD_SIZE_IN * ctx.canvas.width) / 2;
    const halfH = (ROBOT_BOX_SIZE_IN / FIELD_SIZE_IN * ctx.canvas.height) / 2;
    if (fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fillRect(cx - halfW, cy - halfH, halfW * 2, halfH * 2);
    }
    ctx.strokeStyle = strokeStyle || 'rgba(255,255,255,0.85)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(cx - halfW, cy - halfH, halfW * 2, halfH * 2);
  }

  function renderField() {
    const canvas = document.getElementById('fieldCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // Field coords: -72..72 on both axes, y increases upward.
    // Map display mirrors points across X-axis.
    function toC(fx, fy) {
      const my = mirrorMapY(fy);
      return [(fx - FIELD_MIN) / FIELD_SIZE_IN * W, (FIELD_MAX - my) / FIELD_SIZE_IN * H];
    }

    ctx.clearRect(0, 0, W, H);

    // ── Background: FTC field photo ──
    if (fieldImg.complete && fieldImg.naturalWidth > 0) {
      ctx.drawImage(fieldImg, 0, 0, W, H);
      // Darken slightly so overlays read clearly
      ctx.fillStyle = 'rgba(0,0,0,0.28)';
      ctx.fillRect(0, 0, W, H);
    } else {
      // Fallback grid while image loads
      for (let row = 0; row < 6; row++) {
        for (let col = 0; col < 6; col++) {
          const [cx, cy] = toC(-72 + col * 24, 72 - row * 24);
          const tw = 24 / 144 * W, th = 24 / 144 * H;
          ctx.fillStyle = (row + col) % 2 === 0 ? '#272727' : '#1f1f1f';
          ctx.fillRect(cx, cy, tw + 0.5, th + 0.5);
        }
      }
    }

    // Tile grid overlay (subtle white lines)
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 0.75;
    for (let i = FIELD_MIN; i <= FIELD_MAX; i += 24) {
      const [x1, y1] = toC(i, FIELD_MIN), [x2, y2] = toC(i, FIELD_MAX);
      ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
      const [x3, y3] = toC(FIELD_MIN, i), [x4, y4] = toC(FIELD_MAX, i);
      ctx.beginPath(); ctx.moveTo(x3, y3); ctx.lineTo(x4, y4); ctx.stroke();
    }

    // Centre axes (slightly brighter)
    ctx.strokeStyle = 'rgba(255,255,255,0.22)';
    ctx.lineWidth = 1;
    { const [x1,y1]=toC(0,-72),[x2,y2]=toC(0,72); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    { const [x1,y1]=toC(-72,0),[x2,y2]=toC(72,0); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }

    // Field border
    ctx.strokeStyle = 'rgba(255,255,255,0.45)';
    ctx.lineWidth = 2;
    ctx.strokeRect(1, 1, W - 2, H - 2);

    // Axis labels
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.font = '11px Arial';
    ctx.fillText('+y', ...toC(2, 66)); ctx.fillText('-y', ...toC(2, -69));
    ctx.fillText('+x', ...toC(60, 3)); ctx.fillText('-x', ...toC(-71, 3));

    const key = getKey();

    // Known points (white translucent dots + labels)
    (KNOWN_POINTS[key] || []).forEach(pt => {
      const [cx, cy] = toC(pt.x, pt.y);
      drawRobotBox(ctx, toC, pt.x, pt.y, 'rgba(255,255,255,0.28)', 'rgba(255,255,255,0.04)');
      ctx.fillStyle = 'rgba(255,255,255,0.20)';
      ctx.strokeStyle = 'rgba(255,255,255,0.50)';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.65)';
      ctx.font = '9px Arial';
      ctx.fillText(pt.label, cx + 7, cy + 3);
    });

    // ── Start pose ──
    const pose = START_POSES[key];
    let px = pose.x, py = pose.y;
    {
      const [cx, cy] = toC(px, py);
      drawRobotBox(ctx, toC, px, py, 'rgba(94,129,172,0.95)', 'rgba(94,129,172,0.16)');
      // Glow ring
      ctx.shadowColor = '#5e81ac'; ctx.shadowBlur = 12;
      ctx.fillStyle = '#5e81ac';
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, 11, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.shadowBlur = 0;
      // Heading arrow: 0=up(+y), CW positive → canvas angle = (h - 90)°
      const hRad = (pose.heading - 90) * Math.PI / 180;
      const aLen = 22;
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(cx, cy);
      ctx.lineTo(cx + aLen * Math.cos(hRad), cy + aLen * Math.sin(hRad)); ctx.stroke();
      // "S" label
      ctx.fillStyle = '#ffffff'; ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText('S', cx, cy);
      ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
    }

    // ── Draw each step ──
    let colorIdx = 0;
    let samePosCnt = 0; // tracks consecutive stationary steps for stacking markers

    document.querySelectorAll('.step-card').forEach((card, i) => {
      const type = card.querySelector('.step-type').value;
      const color = FIELD_COLORS[colorIdx % FIELD_COLORS.length];

      // ── Drive / Drive + Turn ──
      if (type === 'Drive' || type === 'Drive + Turn') {
        const pts = getDriveWaypoints(card);

        if (pts.length > 0) {
          const allField = [[px, py], ...pts];
          const allC = allField.map(([fx, fy]) => toC(fx, fy));

          // Draw glow shadow for path
          ctx.shadowColor = color; ctx.shadowBlur = 8;
          ctx.strokeStyle = color; ctx.lineWidth = 3.5;
          ctx.setLineDash([]); ctx.lineJoin = 'round';
          drawPolyline(ctx, allC);
          ctx.shadowBlur = 0;

          // Arrowhead — tangent direction at last segment end
          const n = allC.length;
          const prevC = allC[n - 2], lastC = allC[n - 1];
          drawArrow(ctx, prevC, lastC, color);

          // Intermediate waypoint dots (skip first = previous robot pos)
          pts.forEach(([fx, fy]) => {
            const [cx, cy] = toC(fx, fy);
            drawRobotBox(ctx, toC, fx, fy, 'rgba(255,255,255,0.40)', 'rgba(255,255,255,0.03)');
            ctx.fillStyle = color; ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
          });

          // Step number badge near endpoint
          const [lx, ly] = toC(pts[pts.length - 1][0], pts[pts.length - 1][1]);
          ctx.fillStyle = 'rgba(0,0,0,0.65)';
          ctx.fillRect(lx + 7, ly - 16, 18, 14);
          ctx.fillStyle = color; ctx.font = 'bold 11px Arial';
          ctx.fillText(i + 1, lx + 10, ly - 6);

          px = pts[pts.length - 1][0]; py = pts[pts.length - 1][1];
        }

        // Turn arc for Drive+Turn
        if (type === 'Drive + Turn') {
          const angleDeg = parseFloat(card.querySelector('.p-dt-angle')?.value || '0');
          const [cx, cy] = toC(px, py);
          const sweep = Math.min(Math.abs(angleDeg), 300) * Math.PI / 180;
          ctx.strokeStyle = '#ebcb8b'; ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.arc(cx, cy, 18, -Math.PI / 2, -Math.PI / 2 + (angleDeg >= 0 ? sweep : -sweep), angleDeg < 0);
          ctx.stroke(); ctx.setLineDash([]);
          ctx.fillStyle = '#ebcb8b'; ctx.font = 'bold 9px Arial';
          ctx.fillText(`↻${angleDeg}°`, cx + 21, cy - 6);
        }

        colorIdx++;
        samePosCnt = 0;

      // ── Turn ──
      } else if (type === 'Turn') {
        const [cx, cy] = toC(px, py);
        const angleDeg = parseFloat(card.querySelector('.p-turn-angle')?.value || '0');
        const sweep = Math.min(Math.abs(angleDeg), 300) * Math.PI / 180;
        ctx.shadowColor = '#ebcb8b'; ctx.shadowBlur = 6;
        ctx.strokeStyle = '#ebcb8b'; ctx.lineWidth = 2.5;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(cx, cy, 18, -Math.PI / 2, -Math.PI / 2 + (angleDeg >= 0 ? sweep : -sweep), angleDeg < 0);
        ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur = 0;
        // Arrow tip on arc
        const endAng = -Math.PI / 2 + (angleDeg >= 0 ? sweep : -sweep);
        const tipX = cx + 18 * Math.cos(endAng), tipY = cy + 18 * Math.sin(endAng);
        const tipDir = endAng + (angleDeg >= 0 ? Math.PI / 2 : -Math.PI / 2);
        ctx.fillStyle = '#ebcb8b';
        ctx.beginPath();
        ctx.moveTo(tipX, tipY);
        ctx.lineTo(tipX - 7 * Math.cos(tipDir - 0.5), tipY - 7 * Math.sin(tipDir - 0.5));
        ctx.lineTo(tipX - 7 * Math.cos(tipDir + 0.5), tipY - 7 * Math.sin(tipDir + 0.5));
        ctx.fill();
        ctx.fillStyle = '#ebcb8b'; ctx.font = 'bold 9px Arial';
        ctx.fillText(`↻${angleDeg}°`, cx + 22, cy - 8);
        // Step badge
        ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(cx - 23, cy - 30, 18, 13);
        ctx.fillStyle = '#ebcb8b'; ctx.font = 'bold 10px Arial';
        ctx.fillText(i + 1, cx - 19, cy - 21);
        colorIdx++;
        samePosCnt = 0;

      // ── Action markers (Shoot, Wait, Transfer, Aim Turret) ──
      } else {
        const [cx, cy] = toC(px, py);
        const ox = samePosCnt * 30; // horizontal offset to avoid stacking

        if (type === 'Shoot') {
          drawActionMarker(ctx, cx + ox, cy, '#bf616a', '⚡', i + 1, 'SHOOT');
        } else if (type === 'Wait') {
          const ms = card.querySelector('.p-wait-ms')?.value || '?';
          drawActionMarker(ctx, cx + ox, cy, '#81a1c1', '⏸', i + 1, `${ms}ms`);
        } else if (type === 'Transfer') {
          drawActionMarker(ctx, cx + ox, cy, '#d08770', '↺', i + 1, 'XFER');
        } else if (type === 'Aim Turret') {
          drawActionMarker(ctx, cx + ox, cy, '#ebcb8b', '◎', i + 1, 'AIM');
        }
        samePosCnt++;
      }
    });

    const playbackPose = getPlaybackPoseAt(playback.tMs);
    if (playbackPose) {
      const [cx, cy] = toC(playbackPose.x, playbackPose.y);
      drawRobotBox(ctx, toC, playbackPose.x, playbackPose.y, '#88ffd2', 'rgba(136,255,210,0.18)');
      const hRad = (playbackPose.heading - 90) * Math.PI / 180;
      const aLen = 24;
      ctx.strokeStyle = '#88ffd2';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + aLen * Math.cos(hRad), cy + aLen * Math.sin(hRad));
      ctx.stroke();
      ctx.font = 'bold 10px Arial';
      ctx.fillStyle = 'rgba(0,0,0,0.68)';
      const label = playbackPose.label || 'Robot';
      const lw = ctx.measureText(label).width + 10;
      ctx.fillRect(cx - lw / 2, cy - 32, lw, 16);
      ctx.fillStyle = '#88ffd2';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy - 20);
      ctx.textAlign = 'left';
    }
  }

  // Straight polyline through canvas points
  function drawPolyline(ctx, pts) {
    if (pts.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i][0], pts[i][1]);
    }
    ctx.stroke();
  }

  function drawArrow(ctx, [x1, y1], [x2, y2], color) {
    const angle = Math.atan2(y2 - y1, x2 - x1);
    const len = 12;
    ctx.shadowColor = color; ctx.shadowBlur = 6;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - len * Math.cos(angle - Math.PI / 6), y2 - len * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(x2 - len * Math.cos(angle + Math.PI / 6), y2 - len * Math.sin(angle + Math.PI / 6));
    ctx.closePath(); ctx.fill();
    ctx.shadowBlur = 0;
  }

  function drawActionMarker(ctx, cx, cy, color, icon, stepNum, label) {
    const R = 13;
    // Glow + filled circle
    ctx.shadowColor = color; ctx.shadowBlur = 10;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2); ctx.stroke();
    // Icon
    ctx.fillStyle = '#ffffff'; ctx.font = '12px Arial';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(icon, cx, cy);
    // Step number badge (top-right)
    ctx.fillStyle = 'rgba(0,0,0,0.75)';
    ctx.beginPath(); ctx.arc(cx + R - 1, cy - R + 1, 7, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#ffffff'; ctx.font = 'bold 8px Arial';
    ctx.fillText(stepNum, cx + R - 1, cy - R + 1);
    // Label below
    ctx.font = 'bold 9px Arial';
    const lw = ctx.measureText(label).width + 8;
    ctx.fillStyle = 'rgba(0,0,0,0.70)';
    ctx.fillRect(cx - lw / 2, cy + R + 3, lw, 14);
    ctx.fillStyle = '#ffffff';
    ctx.fillText(label, cx, cy + R + 11);
    ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  }

  // ── Event wiring ───────────────────────────────────────────────────────────

  document.getElementById('alliance').addEventListener('change', applyDefaults);
  document.getElementById('startPos').addEventListener('change', applyDefaults);
  document.getElementById('autoName').addEventListener('input', regenerate);
  ['veloL','veloM','veloR','hoodL','hoodM','hoodR','turretAngle','preAimAngle'].forEach(id => {
    document.getElementById(id).addEventListener('input', regenerate);
  });
  document.getElementById('copyBtn').addEventListener('click', () => {
    navigator.clipboard.writeText(document.getElementById('output').textContent)
      .then(() => alert('Copied to clipboard!'));
  });
  document.getElementById('playPauseBtn').addEventListener('click', () => {
    if (playback.isPlaying) {
      stopPlayback();
      renderField();
    } else {
      startPlayback();
    }
  });
  document.getElementById('resetPlaybackBtn').addEventListener('click', () => {
    stopPlayback();
    playback.tMs = 0;
    updatePlaybackUi();
    renderField();
  });
  document.getElementById('playbackSpeed').addEventListener('change', e => {
    const v = parseFloat(e.target.value || '1');
    playback.speed = isNaN(v) ? 1 : Math.max(0.1, v);
  });
  document.getElementById('playbackSeek').addEventListener('input', e => {
    stopPlayback();
    playback.tMs = parseFloat(e.target.value || '0');
    updatePlaybackUi();
    renderField();
  });

  // Initial render
  playback.speed = parseFloat(document.getElementById('playbackSpeed').value || '1') || 1;
  regenerate();
  updatePlaybackUi();
</script>
</body>
</html>
